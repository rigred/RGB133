<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Vision Utils: src/CaptureAudio.c File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>Globals</span></a></li>
  </ul></div>
<h1>src/CaptureAudio.c File Reference</h1><code>#include &lt;stdio.h&gt;</code><br>
<code>#include &lt;stdlib.h&gt;</code><br>
<code>#include &lt;string.h&gt;</code><br>
<code>#include &lt;sched.h&gt;</code><br>
<code>#include &lt;errno.h&gt;</code><br>
<code>#include &lt;getopt.h&gt;</code><br>
<code>#include &lt;alsa/asoundlib.h&gt;</code><br>
<code>#include &lt;sys/time.h&gt;</code><br>
<code>#include &lt;math.h&gt;</code><br>
<code>#include &lt;pthread.h&gt;</code><br>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="CaptureAudio_8c.html#7073a49145b70ea7753f5690e2ea0d32">STARTED</a>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="CaptureAudio_8c.html#d615fd9cb9ac008b4b083d3c0f1dda45">NOT_STARTED</a>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="CaptureAudio_8c.html#a03c98a724e45343cf6567f3711e6370">INCREASE</a>&nbsp;&nbsp;&nbsp;2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="CaptureAudio_8c.html#6647807eb4f3ddb9d911b1e3dcd46c5b">DECREASE</a>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="CaptureAudio_8c.html#d7c6eff16e5926512cfe3802c074d279">CAPTURE_RATE_DEFAULT</a>&nbsp;&nbsp;&nbsp;48000</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="CaptureAudio_8c.html#daeed3c0e3734fb7b73b307f6fcea921">CAPTURE_CHANNELS_DEFAULT</a>&nbsp;&nbsp;&nbsp;2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="CaptureAudio_8c.html#7b2ca2829168f4903f66ad427456431a">CAPTURE_FORMAT_DEFAULT</a>&nbsp;&nbsp;&nbsp;SND_PCM_FORMAT_S16</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="CaptureAudio_8c.html#bc77b27531f71a23169b624ea4a2da15">PLAYBACK_RATE_DEFAULT</a>&nbsp;&nbsp;&nbsp;48000</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="CaptureAudio_8c.html#1c171eb477b31d8c71ada46d727faa16">PLAYBACK_CHANNELS_DEFAULT</a>&nbsp;&nbsp;&nbsp;2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="CaptureAudio_8c.html#08c96b1027df206a9fc61314efa7c1b7">PLAYBACK_FORMAT_DEFAULT</a>&nbsp;&nbsp;&nbsp;SND_PCM_FORMAT_S16</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="CaptureAudio_8c.html#729695df008dcd4daa4872193b712a56">modify_num_frames_ready</a> (int cmd, int val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="CaptureAudio_8c.html#67725161aa01c25a3d07d40f22a3acc8">read_in</a> (void *_handle)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="CaptureAudio_8c.html#81441cc037c3326f5938ffd892457968">write_out</a> (void *_handle)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="CaptureAudio_8c.html#28052c36c3b61c6c0eaa18f5d226118f">main</a> (int argc, char *argv[])</td></tr>

<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">pthread_cond_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="CaptureAudio_8c.html#f4fc2e42393abf38c557e0bcd3c36ffa">eventVariableFilledBuffers</a> = PTHREAD_COND_INITIALIZER</td></tr>

</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="daeed3c0e3734fb7b73b307f6fcea921"></a><!-- doxytag: member="CaptureAudio.c::CAPTURE_CHANNELS_DEFAULT" ref="daeed3c0e3734fb7b73b307f6fcea921" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CAPTURE_CHANNELS_DEFAULT&nbsp;&nbsp;&nbsp;2          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="7b2ca2829168f4903f66ad427456431a"></a><!-- doxytag: member="CaptureAudio.c::CAPTURE_FORMAT_DEFAULT" ref="7b2ca2829168f4903f66ad427456431a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CAPTURE_FORMAT_DEFAULT&nbsp;&nbsp;&nbsp;SND_PCM_FORMAT_S16          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="d7c6eff16e5926512cfe3802c074d279"></a><!-- doxytag: member="CaptureAudio.c::CAPTURE_RATE_DEFAULT" ref="d7c6eff16e5926512cfe3802c074d279" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CAPTURE_RATE_DEFAULT&nbsp;&nbsp;&nbsp;48000          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="6647807eb4f3ddb9d911b1e3dcd46c5b"></a><!-- doxytag: member="CaptureAudio.c::DECREASE" ref="6647807eb4f3ddb9d911b1e3dcd46c5b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DECREASE&nbsp;&nbsp;&nbsp;0          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="a03c98a724e45343cf6567f3711e6370"></a><!-- doxytag: member="CaptureAudio.c::INCREASE" ref="a03c98a724e45343cf6567f3711e6370" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INCREASE&nbsp;&nbsp;&nbsp;2          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="d615fd9cb9ac008b4b083d3c0f1dda45"></a><!-- doxytag: member="CaptureAudio.c::NOT_STARTED" ref="d615fd9cb9ac008b4b083d3c0f1dda45" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NOT_STARTED&nbsp;&nbsp;&nbsp;0          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="1c171eb477b31d8c71ada46d727faa16"></a><!-- doxytag: member="CaptureAudio.c::PLAYBACK_CHANNELS_DEFAULT" ref="1c171eb477b31d8c71ada46d727faa16" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PLAYBACK_CHANNELS_DEFAULT&nbsp;&nbsp;&nbsp;2          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="08c96b1027df206a9fc61314efa7c1b7"></a><!-- doxytag: member="CaptureAudio.c::PLAYBACK_FORMAT_DEFAULT" ref="08c96b1027df206a9fc61314efa7c1b7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PLAYBACK_FORMAT_DEFAULT&nbsp;&nbsp;&nbsp;SND_PCM_FORMAT_S16          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="bc77b27531f71a23169b624ea4a2da15"></a><!-- doxytag: member="CaptureAudio.c::PLAYBACK_RATE_DEFAULT" ref="bc77b27531f71a23169b624ea4a2da15" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PLAYBACK_RATE_DEFAULT&nbsp;&nbsp;&nbsp;48000          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="7073a49145b70ea7753f5690e2ea0d32"></a><!-- doxytag: member="CaptureAudio.c::STARTED" ref="7073a49145b70ea7753f5690e2ea0d32" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STARTED&nbsp;&nbsp;&nbsp;1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="28052c36c3b61c6c0eaa18f5d226118f"></a><!-- doxytag: member="CaptureAudio.c::main" ref="28052c36c3b61c6c0eaa18f5d226118f" args="(int argc, char *argv[])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int main           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>argv</em>[]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<div class="fragment"><pre class="fragment"><a name="l00626"></a>00626 {
<a name="l00627"></a>00627    <span class="keyword">struct </span>option long_option[] =
<a name="l00628"></a>00628  {
<a name="l00629"></a>00629     {<span class="stringliteral">"help"</span>, 0, NULL, <span class="charliteral">'h'</span>},
<a name="l00630"></a>00630     {<span class="stringliteral">"list"</span>, 1, NULL, <span class="charliteral">'l'</span>},
<a name="l00631"></a>00631     {<span class="stringliteral">"device"</span>, 1, NULL, <span class="charliteral">'D'</span>},
<a name="l00632"></a>00632     {<span class="stringliteral">"device_cap"</span>, 1, NULL, <span class="charliteral">'d'</span>},
<a name="l00633"></a>00633     {<span class="stringliteral">"rate"</span>, 1, NULL, <span class="charliteral">'r'</span>},
<a name="l00634"></a>00634     {<span class="stringliteral">"channels"</span>, 1, NULL, <span class="charliteral">'c'</span>},
<a name="l00635"></a>00635     {<span class="stringliteral">"buffer"</span>, 1, NULL, <span class="charliteral">'b'</span>},
<a name="l00636"></a>00636     {<span class="stringliteral">"period"</span>, 1, NULL, <span class="charliteral">'p'</span>},
<a name="l00637"></a>00637     {<span class="stringliteral">"format"</span>, 1, NULL, <span class="charliteral">'o'</span>},
<a name="l00638"></a>00638     {<span class="stringliteral">"List"</span>, 1, NULL, <span class="charliteral">'L'</span>},
<a name="l00639"></a>00639     {<span class="stringliteral">"verbose"</span>, 1, NULL, <span class="charliteral">'v'</span>},
<a name="l00640"></a>00640     {NULL, 0, NULL, 0},
<a name="l00641"></a>00641  };
<a name="l00642"></a>00642    <span class="comment">/* playback variables */</span>
<a name="l00643"></a>00643    <span class="keywordtype">int</span> k, err;
<a name="l00644"></a>00644    snd_pcm_t *handle;
<a name="l00645"></a>00645    snd_pcm_hw_params_t *hwparams;
<a name="l00646"></a>00646    snd_pcm_hw_params_alloca(&amp;hwparams);
<a name="l00647"></a>00647    <span class="comment">// write-out thread</span>
<a name="l00648"></a>00648    pthread_t thread_out;
<a name="l00649"></a>00649    <span class="keywordtype">int</span> ret_thread_out;
<a name="l00650"></a>00650 
<a name="l00651"></a>00651    <span class="comment">/* capture variables */</span>
<a name="l00652"></a>00652    snd_pcm_t *handle_cap;
<a name="l00653"></a>00653    <span class="keywordtype">int</span> count;
<a name="l00654"></a>00654    <span class="comment">// hardware parameters struct for capture</span>
<a name="l00655"></a>00655    snd_pcm_hw_params_t *hwparams_cap;
<a name="l00656"></a>00656    snd_pcm_hw_params_alloca(&amp;hwparams_cap);
<a name="l00657"></a>00657    <span class="comment">// read-in thread</span>
<a name="l00658"></a>00658    pthread_t thread_in;
<a name="l00659"></a>00659    <span class="keywordtype">int</span> ret_thread_in;
<a name="l00660"></a>00660 
<a name="l00661"></a>00661    <span class="comment">/* help and other variables */</span>
<a name="l00662"></a>00662    <span class="keywordtype">int</span> morehelp;
<a name="l00663"></a>00663    <span class="keywordtype">char</span> **devices;
<a name="l00664"></a>00664    <span class="keywordtype">int</span> devicesNum;
<a name="l00665"></a>00665    <span class="keywordtype">int</span> i;
<a name="l00666"></a>00666    <span class="comment">// to hold all the options entered from command line</span>
<a name="l00667"></a>00667    <span class="keywordtype">char</span> options_entered[11] = {0};
<a name="l00668"></a>00668    <span class="keywordtype">char</span> temp[2] = {0};
<a name="l00669"></a>00669 
<a name="l00670"></a>00670    morehelp = 0;
<a name="l00671"></a>00671 
<a name="l00672"></a>00672    <span class="keywordflow">while</span> (1)
<a name="l00673"></a>00673    {
<a name="l00674"></a>00674       <span class="keywordtype">int</span> c;
<a name="l00675"></a>00675       <span class="keywordflow">if</span> ((c = getopt_long(argc, argv, <span class="stringliteral">"hlD:d:r:c:b:p:o:Lv"</span>, long_option, NULL)) &lt; 0)
<a name="l00676"></a>00676          <span class="keywordflow">break</span>;
<a name="l00677"></a>00677       <span class="comment">// Collect all the entered options</span>
<a name="l00678"></a>00678       temp[0] = c;
<a name="l00679"></a>00679       strcat(options_entered, temp);
<a name="l00680"></a>00680 
<a name="l00681"></a>00681       <span class="keywordflow">switch</span> (c) {
<a name="l00682"></a>00682          <span class="keywordflow">case</span> <span class="charliteral">'h'</span>:
<a name="l00683"></a>00683             morehelp++;
<a name="l00684"></a>00684             <span class="keywordflow">break</span>;
<a name="l00685"></a>00685          <span class="keywordflow">case</span> <span class="charliteral">'l'</span>:
<a name="l00686"></a>00686             <span class="comment">// display the list of VISION ALSA capture devices and ALSA playback devices</span>
<a name="l00687"></a>00687             list_alsa_devices(SND_PCM_STREAM_CAPTURE);
<a name="l00688"></a>00688             list_alsa_devices(SND_PCM_STREAM_PLAYBACK);
<a name="l00689"></a>00689             <span class="keywordflow">return</span> 0;
<a name="l00690"></a>00690          <span class="keywordflow">case</span> <span class="charliteral">'D'</span>:
<a name="l00691"></a>00691             device = strdup(optarg);
<a name="l00692"></a>00692             <span class="keywordflow">break</span>;
<a name="l00693"></a>00693          <span class="keywordflow">case</span> <span class="charliteral">'d'</span>:
<a name="l00694"></a>00694             device_cap = strdup(optarg);
<a name="l00695"></a>00695             <span class="keywordflow">break</span>;
<a name="l00696"></a>00696          <span class="keywordflow">case</span> <span class="charliteral">'r'</span>:
<a name="l00697"></a>00697             <span class="comment">// Unsupported rates are handled by snd_pcm_hw_params_set_rate_near()</span>
<a name="l00698"></a>00698             rate_cap = atoi(optarg);
<a name="l00699"></a>00699             <span class="keywordflow">break</span>;
<a name="l00700"></a>00700          <span class="keywordflow">case</span> <span class="charliteral">'c'</span>:
<a name="l00701"></a>00701             channels_cap = atoi(optarg);
<a name="l00702"></a>00702             <span class="keywordflow">break</span>;
<a name="l00703"></a>00703          <span class="keywordflow">case</span> <span class="charliteral">'b'</span>:
<a name="l00704"></a>00704             buffer_time = atoi(optarg);
<a name="l00705"></a>00705             buffer_time = buffer_time &lt; 1000 ? 1000 : buffer_time;
<a name="l00706"></a>00706             buffer_time = buffer_time &gt; 1000000 ? 1000000 : buffer_time;
<a name="l00707"></a>00707             <span class="keywordflow">break</span>;
<a name="l00708"></a>00708          <span class="keywordflow">case</span> <span class="charliteral">'p'</span>:
<a name="l00709"></a>00709             period_time = atoi(optarg);
<a name="l00710"></a>00710             period_time = period_time &lt; 1000 ? 1000 : period_time;
<a name="l00711"></a>00711             period_time = period_time &gt; 1000000 ? 1000000 : period_time;
<a name="l00712"></a>00712             <span class="keywordflow">break</span>;
<a name="l00713"></a>00713          <span class="keywordflow">case</span> <span class="charliteral">'o'</span>:
<a name="l00714"></a>00714             <span class="keywordflow">for</span> (format_cap = 0; format_cap &lt; SND_PCM_FORMAT_LAST; format_cap++)
<a name="l00715"></a>00715             {
<a name="l00716"></a>00716                <span class="keyword">const</span> <span class="keywordtype">char</span> *format_name = snd_pcm_format_name(format_cap);
<a name="l00717"></a>00717                <span class="keywordflow">if</span> (format_name)
<a name="l00718"></a>00718                   <span class="keywordflow">if</span> (!strcasecmp(format_name, optarg))
<a name="l00719"></a>00719                      <span class="keywordflow">break</span>;
<a name="l00720"></a>00720             }
<a name="l00721"></a>00721             <span class="keywordflow">if</span> (format_cap == SND_PCM_FORMAT_LAST)
<a name="l00722"></a>00722             {
<a name="l00723"></a>00723                printf(<span class="stringliteral">"*** Format for capture is not an ALSA format =&gt; using default; (Use -L to display the list of ALSA formats)\n"</span>);
<a name="l00724"></a>00724                format_cap = <a class="code" href="CaptureAudio_8c.html#7b2ca2829168f4903f66ad427456431a">CAPTURE_FORMAT_DEFAULT</a>;
<a name="l00725"></a>00725             }
<a name="l00726"></a>00726             <span class="keywordflow">if</span> (!snd_pcm_format_linear(format_cap) &amp;&amp;
<a name="l00727"></a>00727                !(format_cap == SND_PCM_FORMAT_FLOAT_LE || format_cap == SND_PCM_FORMAT_FLOAT_BE))
<a name="l00728"></a>00728             {
<a name="l00729"></a>00729                printf(<span class="stringliteral">"Invalid (non-linear/float) format %s\n"</span>, optarg);
<a name="l00730"></a>00730                <span class="keywordflow">return</span> 1;
<a name="l00731"></a>00731             }
<a name="l00732"></a>00732             <span class="keywordflow">break</span>;
<a name="l00733"></a>00733          <span class="keywordflow">case</span> <span class="charliteral">'L'</span>:
<a name="l00734"></a>00734             <span class="comment">// display the list of ALSA formats</span>
<a name="l00735"></a>00735             printf(<span class="stringliteral">"List of ALSA formats: "</span>);
<a name="l00736"></a>00736             <span class="keywordflow">for</span> (i = 0; i &lt; SND_PCM_FORMAT_LAST; i++)
<a name="l00737"></a>00737                printf(<span class="stringliteral">"%s "</span>, snd_pcm_format_name(i));
<a name="l00738"></a>00738             printf(<span class="stringliteral">"\n"</span>);
<a name="l00739"></a>00739             <span class="keywordflow">return</span> 0;
<a name="l00740"></a>00740          <span class="keywordflow">case</span> <span class="charliteral">'v'</span>:
<a name="l00741"></a>00741             verbose = 1;
<a name="l00742"></a>00742             <span class="keywordflow">break</span>;
<a name="l00743"></a>00743       }
<a name="l00744"></a>00744    }
<a name="l00745"></a>00745    <span class="keywordflow">if</span> (morehelp) {
<a name="l00746"></a>00746       help();
<a name="l00747"></a>00747       <span class="keywordflow">return</span> 0;
<a name="l00748"></a>00748    }
<a name="l00749"></a>00749    err = snd_output_stdio_attach(&amp;output, stdout, 0);
<a name="l00750"></a>00750    <span class="keywordflow">if</span> (err &lt; 0) {
<a name="l00751"></a>00751       printf(<span class="stringliteral">"Output failed: %s\n"</span>, snd_strerror(err));
<a name="l00752"></a>00752       <span class="keywordflow">return</span> 0;
<a name="l00753"></a>00753    }
<a name="l00754"></a>00754 
<a name="l00755"></a>00755    <span class="comment">// program started with no device arguments: get default capture &amp; playback devices</span>
<a name="l00756"></a>00756    <span class="keywordflow">if</span>((argc == 1) || ((strchr(options_entered, <span class="charliteral">'D'</span>) == 0) &amp;&amp; (strchr(options_entered, <span class="charliteral">'d'</span>) == 0)))
<a name="l00757"></a>00757    {
<a name="l00758"></a>00758       <span class="comment">// Allocate memory for capture and playback devices names</span>
<a name="l00759"></a>00759       device = calloc(32, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
<a name="l00760"></a>00760       device_cap = calloc(32, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
<a name="l00761"></a>00761       printf(<span class="stringliteral">"\n*** No capture and playback devices specified: USING DEFAULT CAPTURE AND PLAYBACK DEVICES!\n"</span>);
<a name="l00762"></a>00762       acquire_default_device(device_cap, SND_PCM_STREAM_CAPTURE);
<a name="l00763"></a>00763       acquire_default_device(device, SND_PCM_STREAM_PLAYBACK);
<a name="l00764"></a>00764    }
<a name="l00765"></a>00765    <span class="comment">// In case only playback device was specified</span>
<a name="l00766"></a>00766    <span class="keywordflow">if</span> ((strchr(options_entered, <span class="charliteral">'D'</span>) != 0) &amp;&amp; (strchr(options_entered, <span class="charliteral">'d'</span>) == 0))
<a name="l00767"></a>00767    {
<a name="l00768"></a>00768       printf(<span class="stringliteral">"*** No capture device specified: USING DEFAULT CAPTURE DEVICE!\n"</span>);
<a name="l00769"></a>00769       device_cap = calloc(32, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
<a name="l00770"></a>00770       acquire_default_device(device_cap, SND_PCM_STREAM_CAPTURE);
<a name="l00771"></a>00771    }
<a name="l00772"></a>00772    <span class="comment">// In case only capture device was specified</span>
<a name="l00773"></a>00773    <span class="keywordflow">if</span> ((strchr(options_entered, <span class="charliteral">'d'</span>) != 0) &amp;&amp; (strchr(options_entered, <span class="charliteral">'D'</span>) == 0))
<a name="l00774"></a>00774    {
<a name="l00775"></a>00775       printf(<span class="stringliteral">"*** No playback device specified: USING DEFAULT PLAYBACK DEVICE!\n"</span>);
<a name="l00776"></a>00776       device = calloc(32, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
<a name="l00777"></a>00777       acquire_default_device(device, SND_PCM_STREAM_PLAYBACK);
<a name="l00778"></a>00778    }
<a name="l00779"></a>00779 
<a name="l00780"></a>00780    <span class="comment">/* Playback: PCM open and parameters initialisation */</span>
<a name="l00781"></a>00781    printf(<span class="stringliteral">"\nPLAYBACK:\n"</span>);
<a name="l00782"></a>00782    <span class="comment">// Open the PCM interface for playback in blocking mode</span>
<a name="l00783"></a>00783    <span class="keywordflow">if</span> ((err = snd_pcm_open(&amp;handle, device, SND_PCM_STREAM_PLAYBACK, 0)) &lt; 0) {
<a name="l00784"></a>00784       printf(<span class="stringliteral">"Playback open error: %s\n"</span>, snd_strerror(err));
<a name="l00785"></a>00785       <span class="keywordflow">return</span> 0;
<a name="l00786"></a>00786    }
<a name="l00787"></a>00787    printf(<span class="stringliteral">"Playback device is %s\n"</span>, device);
<a name="l00788"></a>00788    <span class="keywordflow">if</span> ((err = set_hwparams_playback(handle, hwparams, SND_PCM_ACCESS_RW_INTERLEAVED)) &lt; 0) {
<a name="l00789"></a>00789       printf(<span class="stringliteral">"Setting of hwparams failed: %s\n"</span>, snd_strerror(err));
<a name="l00790"></a>00790       exit(EXIT_FAILURE);
<a name="l00791"></a>00791    }
<a name="l00792"></a>00792 
<a name="l00793"></a>00793    <span class="comment">/* Capture: PCM open and parameters initialisation */</span>
<a name="l00794"></a>00794    printf(<span class="stringliteral">"\nCAPTURE:\n"</span>);
<a name="l00795"></a>00795    <span class="comment">// Open the PCM interface for capture</span>
<a name="l00796"></a>00796    <span class="comment">// in non-blocking mode</span>
<a name="l00797"></a>00797    <span class="keywordflow">if</span> ((err = snd_pcm_open(&amp;handle_cap, device_cap, SND_PCM_STREAM_CAPTURE, 1)) &lt; 0)
<a name="l00798"></a>00798    {
<a name="l00799"></a>00799       printf(<span class="stringliteral">"Capture open error: %s\n"</span>, snd_strerror(err));
<a name="l00800"></a>00800       <span class="keywordflow">return</span> 0;
<a name="l00801"></a>00801    }
<a name="l00802"></a>00802    printf(<span class="stringliteral">"Capture device is %s\n"</span>, device_cap);
<a name="l00803"></a>00803    <span class="comment">// Set capture parameters</span>
<a name="l00804"></a>00804    <span class="keywordflow">if</span> ((err = set_hwparams_capture(handle_cap, hwparams_cap, SND_PCM_ACCESS_RW_INTERLEAVED)) &lt; 0)
<a name="l00805"></a>00805    {
<a name="l00806"></a>00806       printf(<span class="stringliteral">"Setting of hwparams_cap for capture failed: %s\n"</span>, snd_strerror(err));
<a name="l00807"></a>00807       exit(EXIT_FAILURE);
<a name="l00808"></a>00808    }
<a name="l00809"></a>00809 
<a name="l00810"></a>00810    <span class="comment">// print out detailed setup of capture and playback card</span>
<a name="l00811"></a>00811    <span class="keywordflow">if</span> (verbose &gt; 0)
<a name="l00812"></a>00812    {
<a name="l00813"></a>00813     printf(<span class="stringliteral">"PLAYBACK SETUP VERBOSELY:\n"</span>);
<a name="l00814"></a>00814     snd_pcm_dump(handle, output);
<a name="l00815"></a>00815     printf(<span class="stringliteral">"\nCAPTURE SETUP VERBOSELY:\n"</span>);
<a name="l00816"></a>00816     snd_pcm_dump(handle_cap, output);
<a name="l00817"></a>00817    }
<a name="l00818"></a>00818 
<a name="l00819"></a>00819    <span class="comment">// Notify the user in case rates are not equal for capture and playback</span>
<a name="l00820"></a>00820    <span class="keywordflow">if</span> (rate_cap != rate)
<a name="l00821"></a>00821       printf(<span class="stringliteral">"*** Note that rate for capture and rate for playback are not equal =&gt; Playback sound artifacts will occur!\n"</span>);
<a name="l00822"></a>00822 
<a name="l00823"></a>00823    <span class="comment">/* Allocate the buffer for audio data */</span>
<a name="l00824"></a>00824    <span class="comment">// Get the sample resolution in bits</span>
<a name="l00825"></a>00825    <span class="keywordflow">if</span> ((count = snd_pcm_hw_params_get_sbits(hwparams_cap)) &lt; 0)
<a name="l00826"></a>00826    {
<a name="l00827"></a>00827       printf(<span class="stringliteral">"Getting sample resolution for capture failed: %s\n"</span>, snd_strerror(count));
<a name="l00828"></a>00828       exit(EXIT_FAILURE);
<a name="l00829"></a>00829    }
<a name="l00830"></a>00830    <span class="comment">// to bytes</span>
<a name="l00831"></a>00831    sampleResCap = count / 8;
<a name="l00832"></a>00832    buffer_cap_size = period_size_cap * sampleResCap * channels_cap;    <span class="comment">// period_size_in_frames * bytes_per_sample * channels</span>
<a name="l00833"></a>00833    buffers_cap = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) calloc(buffers_cap_no, buffer_cap_size);
<a name="l00834"></a>00834    <span class="keywordflow">if</span> (buffers_cap == NULL)
<a name="l00835"></a>00835    {
<a name="l00836"></a>00836       printf(<span class="stringliteral">"Not enough memory\n"</span>);
<a name="l00837"></a>00837       exit(EXIT_FAILURE);
<a name="l00838"></a>00838    }
<a name="l00839"></a>00839    <span class="comment">// Create capture thread</span>
<a name="l00840"></a>00840    ret_thread_in = pthread_create(&amp;thread_in, NULL, <a class="code" href="CaptureAudio_8c.html#67725161aa01c25a3d07d40f22a3acc8">read_in</a>, (<span class="keywordtype">void</span>*) handle_cap);
<a name="l00841"></a>00841    <span class="keywordflow">if</span>(ret_thread_in)
<a name="l00842"></a>00842    {
<a name="l00843"></a>00843        printf(<span class="stringliteral">"Error - pthread_create() for thread_in; return code: %d\n"</span>, ret_thread_in);
<a name="l00844"></a>00844        exit(EXIT_FAILURE);
<a name="l00845"></a>00845    }
<a name="l00846"></a>00846 
<a name="l00847"></a>00847    <span class="comment">// Create playback thread</span>
<a name="l00848"></a>00848    ret_thread_out = pthread_create(&amp;thread_out, NULL, <a class="code" href="CaptureAudio_8c.html#81441cc037c3326f5938ffd892457968">write_out</a>, (<span class="keywordtype">void</span>*) handle);
<a name="l00849"></a>00849    <span class="keywordflow">if</span>(ret_thread_out)
<a name="l00850"></a>00850    {
<a name="l00851"></a>00851        printf(<span class="stringliteral">"Error - pthread_create() for thread_out; return code: %d\n"</span>,ret_thread_out);
<a name="l00852"></a>00852        exit(EXIT_FAILURE);
<a name="l00853"></a>00853    }
<a name="l00854"></a>00854 
<a name="l00855"></a>00855    <span class="comment">// Suspend the execution of main() until these threads terminate</span>
<a name="l00856"></a>00856    pthread_join(thread_in, NULL);
<a name="l00857"></a>00857    pthread_join(thread_out, NULL);
<a name="l00858"></a>00858 
<a name="l00859"></a>00859    <span class="comment">// Close playback</span>
<a name="l00860"></a>00860    snd_pcm_close(handle);
<a name="l00861"></a>00861    <span class="comment">// Close capture</span>
<a name="l00862"></a>00862    snd_pcm_drain(handle_cap);
<a name="l00863"></a>00863    snd_pcm_close(handle_cap);
<a name="l00864"></a>00864    free(buffers_cap);
<a name="l00865"></a>00865    <span class="comment">// Free memory for device names</span>
<a name="l00866"></a>00866    <span class="comment">// Note that it is valid to free even if we specified device in command line (no calloc as done for default) because in such case strdup allocated memory</span>
<a name="l00867"></a>00867    free(device);
<a name="l00868"></a>00868    free(device_cap);
<a name="l00869"></a>00869 
<a name="l00870"></a>00870    <span class="keywordflow">return</span> 0;
<a name="l00871"></a>00871 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="729695df008dcd4daa4872193b712a56"></a><!-- doxytag: member="CaptureAudio.c::modify_num_frames_ready" ref="729695df008dcd4daa4872193b712a56" args="(int cmd, int val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void modify_num_frames_ready           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<div class="fragment"><pre class="fragment"><a name="l00061"></a>00061 {
<a name="l00062"></a>00062    <span class="comment">// lock the mutex</span>
<a name="l00063"></a>00063    pthread_mutex_lock (&amp;mutex_num_frames_ready);
<a name="l00064"></a>00064 
<a name="l00065"></a>00065    <span class="comment">/* Modify how many frames are ready to go out;</span>
<a name="l00066"></a>00066 <span class="comment">    * do not allow to make it &lt; 0 or bigger than the number of frames we can house in the buffers;</span>
<a name="l00067"></a>00067 <span class="comment">    */</span>
<a name="l00068"></a>00068    <span class="keywordflow">switch</span> (cmd) {
<a name="l00069"></a>00069       <span class="keywordflow">case</span> <a class="code" href="CaptureAudio_8c.html#a03c98a724e45343cf6567f3711e6370">INCREASE</a>:
<a name="l00070"></a>00070          numFramesReady = numFramesReady + val;
<a name="l00071"></a>00071          <span class="keywordflow">if</span> (numFramesReady &gt; (buffers_cap_no * period_size_cap))
<a name="l00072"></a>00072             numFramesReady = buffers_cap_no * period_size_cap;
<a name="l00073"></a>00073          <span class="keywordflow">break</span>;
<a name="l00074"></a>00074       <span class="keywordflow">case</span> <a class="code" href="CaptureAudio_8c.html#6647807eb4f3ddb9d911b1e3dcd46c5b">DECREASE</a>:
<a name="l00075"></a>00075          <span class="keywordflow">if</span> (val &gt; numFramesReady)
<a name="l00076"></a>00076             numFramesReady = 0;
<a name="l00077"></a>00077          <span class="keywordflow">else</span>
<a name="l00078"></a>00078             numFramesReady = numFramesReady - val;
<a name="l00079"></a>00079          <span class="keywordflow">break</span>;
<a name="l00080"></a>00080       <span class="keywordflow">default</span>:
<a name="l00081"></a>00081          <span class="comment">//do nothing</span>
<a name="l00082"></a>00082          <span class="keywordflow">break</span>;
<a name="l00083"></a>00083    }
<a name="l00084"></a>00084 
<a name="l00085"></a>00085    <span class="comment">// unlock the mutex</span>
<a name="l00086"></a>00086    pthread_mutex_unlock (&amp;mutex_num_frames_ready);
<a name="l00087"></a>00087 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="67725161aa01c25a3d07d40f22a3acc8"></a><!-- doxytag: member="CaptureAudio.c::read_in" ref="67725161aa01c25a3d07d40f22a3acc8" args="(void *_handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* read_in           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>_handle</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<div class="fragment"><pre class="fragment"><a name="l00091"></a>00091 {
<a name="l00092"></a>00092    snd_pcm_t* handle_cap = (snd_pcm_t*) _handle;
<a name="l00093"></a>00093    <span class="keywordtype">int</span> j, error, rc;
<a name="l00094"></a>00094 
<a name="l00095"></a>00095    readInPtr = buffers_cap;
<a name="l00096"></a>00096    <span class="comment">// space left in the buffers in frames</span>
<a name="l00097"></a>00097    spaceLeftInBuffs = buffers_cap_no * period_size_cap;
<a name="l00098"></a>00098 
<a name="l00099"></a>00099    <span class="comment">//Read loop</span>
<a name="l00100"></a>00100    <span class="keywordflow">while</span>(1)
<a name="l00101"></a>00101    {
<a name="l00102"></a>00102       <span class="comment">// Sleep for 30ms so that we do not read data too often. If we read too often, we get a lot of -EAGAINs since data is not ready.</span>
<a name="l00103"></a>00103       <span class="comment">// Note that sleep time should depend on DMA and capture rate: ((rate_in_bytes_per_sec * x) / 1000) = period_size_in_bytes</span>
<a name="l00104"></a>00104       <span class="comment">// ... we should wait for at least x msec not to get -EAGAINs</span>
<a name="l00105"></a>00105       usleep(30000);
<a name="l00106"></a>00106       <span class="comment">// Read whatever the driver has got ready;</span>
<a name="l00107"></a>00107       <span class="comment">// but no more than we can house in the buffers</span>
<a name="l00108"></a>00108       error = snd_pcm_readi (handle_cap, readInPtr, spaceLeftInBuffs);
<a name="l00109"></a>00109       <span class="keywordflow">if</span> (error == -EAGAIN)
<a name="l00110"></a>00110          <span class="keywordflow">continue</span>;
<a name="l00111"></a>00111       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (error &lt; 0)
<a name="l00112"></a>00112       {
<a name="l00113"></a>00113          printf(<span class="stringliteral">"readi error: (%d)\n"</span>, error);
<a name="l00114"></a>00114          exit(1);
<a name="l00115"></a>00115       }
<a name="l00116"></a>00116       <span class="keywordflow">else</span>
<a name="l00117"></a>00117       {
<a name="l00118"></a>00118          <span class="comment">/* After successful readi(), increase the pointer and decrease how much space is left in the buffers */</span>
<a name="l00119"></a>00119          readInPtr = readInPtr + (error * sampleResCap * channels_cap);    <span class="comment">// frames_read * bytes_per_sample * channels;</span>
<a name="l00120"></a>00120          spaceLeftInBuffs = spaceLeftInBuffs - error;
<a name="l00121"></a>00121 
<a name="l00122"></a>00122          <span class="comment">/* Cyclic buffer: reset the pointer */</span>
<a name="l00123"></a>00123          <span class="keywordflow">if</span>(spaceLeftInBuffs == 0)
<a name="l00124"></a>00124          {
<a name="l00125"></a>00125             readInPtr = buffers_cap;
<a name="l00126"></a>00126             spaceLeftInBuffs = buffers_cap_no * period_size_cap;
<a name="l00127"></a>00127          }
<a name="l00128"></a>00128 
<a name="l00129"></a>00129          <span class="comment">/* Increment the number of frames ready to be written out to sound card; */</span>
<a name="l00130"></a>00130          <a class="code" href="CaptureAudio_8c.html#729695df008dcd4daa4872193b712a56">modify_num_frames_ready</a>(<a class="code" href="CaptureAudio_8c.html#a03c98a724e45343cf6567f3711e6370">INCREASE</a>, error);
<a name="l00131"></a>00131 
<a name="l00132"></a>00132          <span class="comment">/*</span>
<a name="l00133"></a>00133 <span class="comment">          * We have filled some buffers; send out the news for whoever is interested;</span>
<a name="l00134"></a>00134 <span class="comment">          * This covers two cases:</span>
<a name="l00135"></a>00135 <span class="comment">          * (1) Initially we wait until the buffer is filled with at least (3 * period_size) of data before we start playback,</span>
<a name="l00136"></a>00136 <span class="comment">          * (2) or we want to wake up the thread which is waiting for data</span>
<a name="l00137"></a>00137 <span class="comment">          */</span>
<a name="l00138"></a>00138          <span class="comment">// start playback when we have at least (3 * period_size) of data in the buffer</span>
<a name="l00139"></a>00139          <span class="comment">// note that period size for playback and period size for capture are now set to be equal</span>
<a name="l00140"></a>00140          <span class="comment">// it simplifies calculations for various clauses (e.g. the one beneath) and things become clearer in general</span>
<a name="l00141"></a>00141          <span class="comment">//if((numFramesReady &gt;= ((buffers_cap_no * period_size_cap)/2)) || (is_started == STARTED))</span>
<a name="l00142"></a>00142          <span class="keywordflow">if</span>((numFramesReady &gt;= (period_size_cap * 3)) || (is_started == <a class="code" href="CaptureAudio_8c.html#7073a49145b70ea7753f5690e2ea0d32">STARTED</a>))
<a name="l00143"></a>00143          {
<a name="l00144"></a>00144             is_started = <a class="code" href="CaptureAudio_8c.html#7073a49145b70ea7753f5690e2ea0d32">STARTED</a>;
<a name="l00145"></a>00145             rc = pthread_cond_signal(&amp;<a class="code" href="CaptureAudio_8c.html#f4fc2e42393abf38c557e0bcd3c36ffa">eventVariableFilledBuffers</a>);
<a name="l00146"></a>00146             <span class="keywordflow">if</span> (rc != 0)
<a name="l00147"></a>00147             {
<a name="l00148"></a>00148                printf(<span class="stringliteral">"read_in: signalling event of filled buffers failed: (%d)\n"</span>, rc);
<a name="l00149"></a>00149                exit(EXIT_FAILURE);
<a name="l00150"></a>00150             }
<a name="l00151"></a>00151          }
<a name="l00152"></a>00152       }
<a name="l00153"></a>00153    }
<a name="l00154"></a>00154 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="81441cc037c3326f5938ffd892457968"></a><!-- doxytag: member="CaptureAudio.c::write_out" ref="81441cc037c3326f5938ffd892457968" args="(void *_handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* write_out           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>_handle</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<div class="fragment"><pre class="fragment"><a name="l00158"></a>00158 {
<a name="l00159"></a>00159    snd_pcm_t* handle = (snd_pcm_t*) _handle;
<a name="l00160"></a>00160    <span class="keywordtype">int</span> cptr, err;
<a name="l00161"></a>00161 
<a name="l00162"></a>00162    writeOutPtr = buffers_cap;
<a name="l00163"></a>00163 
<a name="l00164"></a>00164    <span class="keywordflow">while</span>(1)
<a name="l00165"></a>00165    {
<a name="l00166"></a>00166       <span class="comment">/* Wait for the event to be signalled that buffers have been filled;</span>
<a name="l00167"></a>00167 <span class="comment">       * This covers two cases:</span>
<a name="l00168"></a>00168 <span class="comment">       * (1) Initially, when we start writing out, we want to wait for the buffers to get filled;</span>
<a name="l00169"></a>00169 <span class="comment">       * (2) Similarly, if it happens that we write_out faster than read_in, we want to wait;</span>
<a name="l00170"></a>00170 <span class="comment">       */</span>
<a name="l00171"></a>00171       pthread_cond_wait(&amp;<a class="code" href="CaptureAudio_8c.html#f4fc2e42393abf38c557e0bcd3c36ffa">eventVariableFilledBuffers</a>, &amp;mutex_protect_event_variable);
<a name="l00172"></a>00172 
<a name="l00173"></a>00173       <span class="keywordflow">while</span>(numFramesReady &gt;= period_size)
<a name="l00174"></a>00174       {
<a name="l00175"></a>00175          cptr = period_size;
<a name="l00176"></a>00176          <span class="keywordflow">while</span> (cptr &gt; 0)
<a name="l00177"></a>00177          {
<a name="l00178"></a>00178             err = snd_pcm_writei(handle, writeOutPtr, cptr);
<a name="l00179"></a>00179             <span class="keywordflow">if</span> (err == -EAGAIN)
<a name="l00180"></a>00180                <span class="keywordflow">continue</span>;
<a name="l00181"></a>00181             <span class="keywordflow">if</span> (err &lt; 0)
<a name="l00182"></a>00182             {
<a name="l00183"></a>00183                printf(<span class="stringliteral">"write_out error: %s\n"</span>, snd_strerror(err));
<a name="l00184"></a>00184                <span class="keywordflow">if</span> (xrun_recovery(handle, err) &lt; 0)
<a name="l00185"></a>00185                {
<a name="l00186"></a>00186                   printf(<span class="stringliteral">"write_out error: %s\n"</span>, snd_strerror(err));
<a name="l00187"></a>00187                   exit(EXIT_FAILURE);
<a name="l00188"></a>00188                }
<a name="l00189"></a>00189                <span class="keywordflow">break</span>; <span class="comment">// skip one period</span>
<a name="l00190"></a>00190             }
<a name="l00191"></a>00191             cptr -= err;
<a name="l00192"></a>00192 
<a name="l00193"></a>00193             <span class="comment">// We have successfully written_out some frames;</span>
<a name="l00194"></a>00194             <span class="comment">// increment write_out pointer</span>
<a name="l00195"></a>00195             <span class="comment">//writeOutPtr = writeOutPtr + (err * sizeof(buffers_cap[0]) * sampleResCap * channels_cap);</span>
<a name="l00196"></a>00196             writeOutPtr = writeOutPtr + (err * sampleResCap * channels_cap);
<a name="l00197"></a>00197             <span class="comment">// frames_written_out * bytes_per_sample * channels;</span>
<a name="l00198"></a>00198             <span class="comment">// Decrease the variable which shows how many frames are ready to be written out to sound card;</span>
<a name="l00199"></a>00199             <a class="code" href="CaptureAudio_8c.html#729695df008dcd4daa4872193b712a56">modify_num_frames_ready</a>(<a class="code" href="CaptureAudio_8c.html#6647807eb4f3ddb9d911b1e3dcd46c5b">DECREASE</a>, err);
<a name="l00200"></a>00200 
<a name="l00201"></a>00201             <span class="comment">/* Cyclic buffer */</span>
<a name="l00202"></a>00202             <span class="keywordflow">if</span>(writeOutPtr &gt;= (buffers_cap + buffers_cap_no * buffer_cap_size))
<a name="l00203"></a>00203             {
<a name="l00204"></a>00204                writeOutPtr = buffers_cap;
<a name="l00205"></a>00205             }
<a name="l00206"></a>00206          }
<a name="l00207"></a>00207       }
<a name="l00208"></a>00208    }
<a name="l00209"></a>00209 }
</pre></div>
<p>

</div>
</div><p>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="f4fc2e42393abf38c557e0bcd3c36ffa"></a><!-- doxytag: member="CaptureAudio.c::eventVariableFilledBuffers" ref="f4fc2e42393abf38c557e0bcd3c36ffa" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pthread_cond_t <a class="el" href="CaptureAudio_8c.html#f4fc2e42393abf38c557e0bcd3c36ffa">eventVariableFilledBuffers</a> = PTHREAD_COND_INITIALIZER          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Thu Apr 13 14:13:23 2023 for Vision Utils by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
